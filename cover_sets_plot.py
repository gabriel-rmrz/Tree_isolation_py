import time
import numpy as np
#import pandas as pd
#import awkward as awk
import scipy.io
from collections import defaultdict
from tools.neighbor_distances import neighbor_distances
from plotting.plot_point_cloud import plot_point_cloud



def cover_sets_plot(P,inputs, test=False):

  '''
  ---------------------------------------------------------------------
  COVER_SETS_PLOT.M    Creates cover sets (surface patches) and their
                        neighbor-relation, normals, directions, and dimensions 
                        for point clouds sampling whole forets plot
  
  Version 1.0
  Latest update       18 Dec 2019
  
  Copyright (C) 2015-2019 Pasi Raumonen
  ---------------------------------------------------------------------
  
  Covers the point cloud with small sets, which are along the surface, 
  such that each point belongs at most one cover set; i.e. the cover is 
  a partition of the point cloud. The covers are generated by first
  partitioning the point cloud into big cubes (size NCubes * BallRad) and 
  then generating the covers for each cube as follows:
  First the point cloud (inside a big cube) is covered 
  with balls with radius BallRad. This first cover is such that 
  1) the minimum distance between the centers is PatchDiam, and
  2) the maximum distance from any point to nearest center is also PatchDiam.
  Then the first cover of BallRad-balls is used to define a second cover:
  each BallRad-ball A defines corresponding cover set B in the second cover
  such that B contains those points of A that are nearer to the center of
  A than any other center of BallRad-balls. The BallRad-balls also define
  the neighbors for the second cover: Let CA and CB denote cover sets in
  the second cover, and BA and BB their BallRad-balls. Then CB is
  a neighbor of CA, and vice versa, if BA and CB intersect or
  BC and CA intersect. 
  
  Inputs:
  P         Point cloud
  inputs    Structure array, need to contain the following field
    PatchDiam   Minimum distance between centers of cover sets; i.e. the
                    minimum diameter of a cover set
    BallRad     Radius of the balls used to generate the cover sets, these
                    balls are also used to determine the neighbors
    nmin        Minimum number of points in a rcov-ball
    NCubes      Scalar, how many BallRad-cubes form the side of the bigger cubes
  
  Outputs:
  cover     Structure array with the following fields
    ball        Cover sets, (n_sets x 1)-cell
    center      Center points of the cover sets, (n_sets x 1)-vector
    neighbor    Neighboring cover sets of each cover set, (n_sets x 1)-cell
    normal      Surface normal, unit vector, (n_setc x 3)-matrix
    direction   Set direction, unit vector, (n_setc x 3)-matrix
    dimension   Dimensionality, (n_setc x 3)-matrix   
  '''

  print('  -----------------------')
  print('   Covering point cloud...')
  print('  -----------------------')

  
  ## Large balls and centers
  # Partition the space into rectangular cuboids, whose base (x,y) has
  # NCubes*BallRad size length, and generate the balls one cuboid at the
  # time.
  # % Only double precision data
  # if ~isa(P,'double')
  #     P = double(P);
  # end

  

  i_time = time.time()
  numP = len(P[:,0])
  #print(numP)
  #Ball = defaultdict(list) 
  Ball = {} 
  # large balls, used to generate the cover sets and their neighbors:
  Cen = np.zeros(numP, dtype=np.uint32) # the center points of the balls/cover sets
  BoP = np.zeros(numP, dtype=np.uint32) # the balls/cover sets the points belong
  Ind = np.arange(numP, dtype=np.uint32)
  NotExa = np.ones(numP) # Points not yet examined
  Dist = 1e8 * np.ones(numP, dtype=np.double) # Distance of point to the closest center
  numB = 0 # Number of sets generated

  # Use squared values to avoid square root computations:
  Radius = inputs['BallRad']**2
  MaxDist = inputs['PatchDiam']**2
  NCubes = inputs['NCubes']

  # Calculate the cube coordinates (BallRad - cubes)


  #CC = P[['x','y','z']]
  Min = P.min(axis=0) # Minimum coordinates
  Max = P.max(axis=0) # Maximum coordinates
  

  CC = (np.floor(((P-Min)/inputs['BallRad'])) + 2).astype(np.uint32)

  # Number of rectangular cuboids
  NRectangles = (np.ceil(CC[:,:2].max(axis=0)/NCubes)).astype(np.uint32)

  # Number of BallRad cubes vertically:
  HCubes = np.ceil((Max[2] - Min[2])/inputs['BallRad'])

  isPass = True

  for i in range(1, NRectangles[0] + 1):
    for j in range(1, NRectangles[1] + 1):
      # Select the points
      #print( CC.x <= (2 + i*NCubes))
      #print((CC.x >= (1+(i-1)*NCubes)) & (CC.x <= (2 + i*NCubes)))
      J1 = CC[:,0] >= (1+ (i-1)*NCubes)
      J2 = CC[:,0] <= (2 + (i)*NCubes)
      J3 = CC[:,1] >= (1 + (j -1)*NCubes)
      J4 = CC[:,1] <= (2 + j*NCubes)
      J = np.asarray(J1 & J2 & J3 & J4)
      ind = Ind[J] # the points
      
      cc = CC[J,:] # cube cordinates of the points
      n = cc.shape[0] # Number of points
      # correct the coordinates:
      cc[:,0] = cc[:,0] - (i-1) * NCubes # cube cordinates of the points
      cc[:,1] = cc[:,1] - (j-1) * NCubes # cube cordinates of the points
      S =  cc[:,0] + (NCubes + 2)*(cc[:,1]-1) + ((NCubes + 2)**2)*(cc[:,2] -1)
      Ord = np.argsort(S)
      #S = np.sort(S)
      S = S[Ord]

      Partition = defaultdict(list) 
      #Partition = {} 
      #########################################
      '''
      S_unique, S_ind, S_inv = np.unique(S, return_index=True, return_inverse=True, axis=0)
      for S_i in S_ind:
        Partition[tuple(cc[S_i])] = Ind[S_ind[S_inv]==S_i]

      '''

      #########################################
      p = 1 # The index of the point under comparison
      while p <= n:
        t = 1
        while (p+t <= n) and (S[p-1] == S[p-1+t]):
          t = t + 1
        q = Ord[p-1]
        #print(q)
        #print(cc[q,:])
        key = tuple(cc[q,:])

        Partition[key] = Ind[Ord[p-1:p+t-1]]
        #print(Partition[key])

        p=p+t
      
      
      # Define the points inside the big volume
      Inside = ~((cc[:,0] == 1) | (cc[:,0] == (NCubes +2)) | (cc[:,1] == 1) | (cc[:,1] == (NCubes +2)))
      # Generate the balls
      sd = 1
      RandPerm = (np.random.default_rng(seed=sd).permutation(n)).astype(np.uint32)
      '''
      if test:
        RandPerm = scipy.io.loadmat('RandPerm.mat')
        print(f"RandPerm.keys(): {RandPerm.keys()}")
        RandPerm = RandPerm['RandPerm']-1
      else:
        RandPerm = np.random.permutation(n)
      '''
      #RandPerm = np.random.default_rng(seed=2).permutation(n)
    
      for k in range(n):
        Q = RandPerm[k]
        if (NotExa[ind[Q]] and Inside[Q ]):
          points = []#
          for l in [cc[Q,0]-1, cc[Q,0] , cc[Q,0] + 1]:
            for m in [cc[Q,1]-1, cc[Q,1] , cc[Q,1] + 1]:
              for r in [cc[Q,2]-1, cc[Q,2] , cc[Q,2] + 1]:
                #if((l,m,r) in Partition.keys()):
                for part in Partition[(l,m,r)]:
                  #print(part)
                  points.append(part)
          Q = (ind[Q]).astype(np.uint32)
          points = np.asarray(points, dtype=np.uint32)
          #print(points)
          #print(len(points))


          V = P[points,:]-P[Q]
          V = np.power(V,2)

          dist = V.sum(axis=1) 
          J2 = np.asarray(dist < Radius)
          #print(sum(J2))
          #print(J2)
          #J = np.asarray(dist < Radius)
          '''
          for m in points:
            if m == 24563:
              print(f"Im here, Q: {Q}")
              print(f"Im here, numB: {numB}")
          '''

          if np.count_nonzero(J2) >= inputs['nmin']:
            #print(len(J2))
            #print(len(points))
            I = points[J2]
            d = dist[J2]
            J3 = dist < MaxDist 
            NotExa[points[J3]] = False
            Ball[numB] = I 
            Cen[numB] = Q
            D = Dist[I]
            L = d < D
            I2 = I[L]
            Dist[I2] = d[L]
            BoP[I2] = numB 
            numB = numB + 1
            '''
            if isPass and int(numB) ==int(1e6):
              N1 = np.ceil(numP/np.sum(int(NotExa) != 0))*int(2e6)
              Cen[N1] = 0
              isPass = False
            '''
            if not(numB%int(1e6)):
              print(f"{numB} {round(np.count_nonzero([not elem for elem in NotExa])/numP * 100)}")
              print(f"{f_time - i_time} {round(numP/np.count_nonzero([not elem for elem in NotExa]) * t)}")

  '''
  for k in Ball.keys():
    print(f"{k}: {len(Ball[k])}")
  '''
  #Ball = { d:Ball[d] for d in set(Ball).intersection(range(numB))}
  #print(Ball)
  Cen = (Cen[:numB]).astype(np.uint32)

  f_time = time.time()
  print('Balls and centers generated')
  print(f"Time elapsed: {f_time -i_time}")

  ## Cover sets
  # Number of points in each ball and index of each point in its ball

  i_time = time.time()
  Num = np.zeros(numB, dtype=np.uint32)
  Ind = np.zeros(numP, dtype=np.uint32)

  for i in range(numP):
    if BoP[i] >= 0:
      Num[BoP[i]] += 1
      Ind[i] = Num[BoP[i]] - 1
    

  # Initialization of the Bal
  Bal = {}
  for i in range(numB):
    Bal[i] = np.zeros(int(Num[i]), dtype=np.uint32)
  
  # Define the Bal
  for i in range(numP):
    if BoP[i] >= 0:
      Bal[BoP[i]][Ind[i]]= i

  f_time = time.time()
  
  print('Cover sets defined')
  print(f"Time elapsed: {f_time -i_time}")



  ## Neighbors
  # Define neighbors. Simple rule: Sets A and B are neighbors if the large
  # ball of A contains points of B. Notice that this si not a symmetric relation.
  i_time = time.time()
  Nei = {}
  Fal = np.zeros(int(numB), dtype='bool')
  for i in range(numB):
    B = Ball[i] # the points in the big ball of cover set "i"
    
    
    I = (BoP[B] != i)

    N = B[I] # the points of the B not in the cover set "i"
    N = BoP[N]

    # select the unique elements of N:
    n = len(N)
    if n > 2:
      Include = np.ones(int(n), dtype='bool')
      for j in range(n):
        if not Fal[N[j]]:
          Fal[N[j]] = True
        else:
          Include[j] = False
      Fal[N] = False
      N = N[Include]
    elif n == 2:
      if N[0] == N[1]:
        N = np.array([N[0]])
    Nei[i] = N.astype(np.uint32)

  
  # Make the relation symmetric by adding, if needed, A as B's neighbor
  # in the case B is A's neighbor

  for i in range(numB):
    N_i = Nei[i]
    for j in range(len(N_i)):
      #print(f"N_i: {N_i}")
      #print(f"N_{i}[{j}]: {N_i[j]}")
      K = (Nei[N_i[j]] == i)
      if not np.any(K):
         np.append(Nei[N_i[j]],i)
  
  f_time = time.time()
  print('Neighbors defined')
  print(f"Time elapsed: {f_time -i_time}")

  ## Define the ouput and display statistics


  cover = {}
  cover["ball"] = Bal
  cover["center"] = Cen
  cover["neighbor"] = Nei

  i_time = time.time()
  cover["NeiDis"] = neighbor_distances(P, cover)

  f_time = time.time()
  print("Neighbor distances determaned")
  print(f"Time elapsed: {f_time -i_time}")

  cover["BallOfPoint"] = BoP 
  cover["inputs"] = inputs

  n = sum([len(val) for val in Bal.values()])
  print(f"      {numB} cover sets, {numP -n} points not covered")
  return cover

